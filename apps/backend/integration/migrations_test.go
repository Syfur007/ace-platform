package integration_test

import (
	"context"
	"fmt"
	"math/rand/v2"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
	"time"
	"net/url"

	"github.com/jackc/pgx/v5/pgxpool"
)

func TestMigrateCLI_AppliesSchemaAndSeeds(t *testing.T) {
	ctx := context.Background()

	baseURL := os.Getenv("DATABASE_URL")
	if baseURL == "" {
		t.Fatalf("DATABASE_URL is required (run via docker compose so the test can reach the db service)")
	}

	adminURL, testURL, dbName, err := prepareTestDatabase(ctx, baseURL)
	if err != nil {
		t.Fatalf("prepare test db: %v", err)
	}
	t.Cleanup(func() {
		_ = dropTestDatabase(context.Background(), adminURL, dbName)
	})

	wd, err := os.Getwd()
	if err != nil {
		t.Fatalf("getwd: %v", err)
	}
	apiGatewayDir := filepath.Clean(filepath.Join(wd, ".."))

	cmd := exec.CommandContext(ctx,
		"go", "run", "./cmd/migrate",
		"--database", testURL,
		"--path", "./migrations",
		"up",
	)
	cmd.Dir = apiGatewayDir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("migrate up failed: %v\n%s", err, string(out))
	}

	ctx2, cancel := context.WithTimeout(ctx, 20*time.Second)
	defer cancel()
	pool, err := pgxpool.New(ctx2, testURL)
	if err != nil {
		t.Fatalf("connect: %v", err)
	}
	defer pool.Close()

	assertTableExists(t, ctx2, pool, "users")
	assertTableExists(t, ctx2, pool, "exam_packages")
	assertTableExists(t, ctx2, pool, "question_bank_difficulties")

	var pkgCount int
	if err := pool.QueryRow(ctx2, `select count(*) from exam_packages`).Scan(&pkgCount); err != nil {
		t.Fatalf("count exam_packages: %v", err)
	}
	if pkgCount < 3 {
		t.Fatalf("expected >= 3 exam_packages seeded, got %d", pkgCount)
	}

	var diffCount int
	if err := pool.QueryRow(ctx2, `select count(*) from question_bank_difficulties`).Scan(&diffCount); err != nil {
		t.Fatalf("count question_bank_difficulties: %v", err)
	}
	if diffCount < 3 {
		t.Fatalf("expected >= 3 question_bank_difficulties seeded, got %d", diffCount)
	}
}

func prepareTestDatabase(ctx context.Context, base string) (adminURL string, testURL string, dbName string, err error) {
	u, err := url.Parse(base)
	if err != nil {
		return "", "", "", err
	}
	// Use the same host/user creds but connect to postgres DB for admin ops.
	admin := *u
	admin.Path = "/postgres"

	dbName = fmt.Sprintf("ace_migrate_test_%d_%d", time.Now().Unix(), rand.IntN(1_000_000))
	dbName = strings.ToLower(dbName)

	pool, err := pgxpool.New(ctx, admin.String())
	if err != nil {
		return "", "", "", err
	}
	defer pool.Close()

	// CREATE DATABASE does not support parameters for identifiers.
	// dbName is generated by us and restricted to safe characters.
	if _, err := pool.Exec(ctx, "create database "+dbName); err != nil {
		return "", "", "", err
	}

	testU := *u
	testU.Path = "/" + dbName
	return admin.String(), testU.String(), dbName, nil
}

func dropTestDatabase(ctx context.Context, adminURL string, dbName string) error {
	pool, err := pgxpool.New(ctx, adminURL)
	if err != nil {
		return err
	}
	defer pool.Close()

	// Best-effort cleanup.
	_, _ = pool.Exec(ctx, "revoke connect on database "+dbName+" from public")
	_, _ = pool.Exec(ctx, "select pg_terminate_backend(pid) from pg_stat_activity where datname='"+dbName+"'")
	_, err = pool.Exec(ctx, "drop database if exists "+dbName)
	return err
}

func assertTableExists(t *testing.T, ctx context.Context, pool *pgxpool.Pool, table string) {
	t.Helper()
	var regclass string
	if err := pool.QueryRow(ctx, `select to_regclass('public.' || $1)`, table).Scan(&regclass); err != nil {
		t.Fatalf("to_regclass(%s): %v", table, err)
	}
	if regclass == "" {
		t.Fatalf("expected table %s to exist", table)
	}
}

